# 预测编码技术
预测是一种重要的编码技术。在传输系统的接收端，如果解码器可以用某种方式预测信号，即使预测信息有错误（一般称之为残差，*residuals*），解码器就可以重建输入信号的近似版本。但是，如果残差是已知的，或者将残差传输到解码器，此时解码器就可以更完美的重建原始信号。预测编码技术利用了残差信息这一原理。预测编码可以是有损的，也可以是无损的。接下会介绍几种预测技术。

## 无损预测编码
通过利用空间冗余，像素可以通过相邻的像素预测。因为相邻像素之间的差异很小，编码差异而不是编码实际像素是一种更有效的方式。这种方法称为差分脉冲编码调制（*DPCM*）技术。在DPCM中，存储了最可能的估计，并且计算实际像素$$x$$与其最可能的预测$$x'$$之间的差异。该差异$$e=x-x'$$称为误差信号，并且通常使用可变长度编码进行熵编码。

为了获得更好的估计，可以用之前的少量像素的线性组合来预测。由于解码器已经完成对先前的像素的解码，因此可以使用它们来预测当前像素以获得$$x'$$，并且在接收到误差信号$$e$$时，解码器可以执行$$e + x'$$以获得真实像素值。 图2-20显示了这个概念。

![](../images/2_20.png)

**图2-20.** DPCM预测两行像素的示例

在图2-20的例子中，可以根据先前解码的像素的线性组合来预测当前像素$$X$$。例如，根据相关性，$$X = 0.75A - 0.25B + 0.5C$$。一般而言，预测的图像和原始图像之间会存在有一定的误差，但是与原始图像相比，预测后的图像有更小的方差以及更少的空间相关性。因此，在DPCM中，可以使用诸如霍夫曼编码或算术编码的可变长度编码对预测后的图像进行编码。由此，这种方法产生的压缩是无损压缩。

很多应用会综合利用无损压缩和有损的预测算法实现更短的传输时间，例如医学成像等。然而，这些应用可能只能容忍很小的质量下降，并且期望具备高质量的图像重建。为了实现这一目的，需要首先使用有效的有损压缩算法来构造图像的低带宽版本；然后，计算有损版本和原始图像之间的差异来生成残差（*residual*）图像；最后对残差图像进行无损编码。

## 有损预测编码
在有损编码中，允许部分视觉质量损失以适应更低的比特率，更多的质量降级可以实现更大的数据压缩。图2-21显示了有损编码的一般概念，其中将原始图像分解/变换到频域空间，并对频域信息进行量化处理，然后利用熵编码技术来编码剩余信息。

![](../images/2_21.png)

**图2-21.** 有损编码方案

分解和变换会降低信号的动态范围并且还使信号失去相关性，从而可以产生一种可以高效编码的数据格式。分解和变换通常是可逆的、无损的。然而，在接下来的量化过程，会引入信息损失并因此引入质量降级。但是量化处理也同时实现了数据压缩。接下来的熵编码也是无损处理，但是却通过统计冗余来提供一些压缩。

## 有损DPCM
如前所述的在结合无损DPCM编码的预测编码中，可以基于参考形成预测或估计，然后计算预测信号和原始信号的误差并对误差进行编码。然而，DPCM方案也可以用于有损编码并产生有损预测编码。

可以采用原始信号作为预测的参考帧，然而，传输信道的接收端的解码器将仅能基于到目前为止接收到的数据重现部分信号。需要注意的是，接收到的信号是从信号的量化版本重建，因此会包含量化噪声。故而，在重建信号和原始信号之间会存在差异。

为了确保传输信道收、发两端具有相同的预测，编码器还需要基于重建值形成其预测。如图2-22所示，为实现这一点，需要将量化器包含在预测循环中，这实际上相当于将解码器和编码结构合并在了一起。

![](../images/2_22.png)

**图2-22.** 有损DPCM流程图

## 时域预测
除了利用相邻像素之间的空间冗余预测外，还可以利用时间冗余从相邻帧形成预测。除了物体在帧之间的微小移动外，相邻帧是相似的，因此可以捕获帧的差异信号并且可用通过运动来补偿帧的残差信息。

当帧被分成不同的像素块时，不同的块可能会移动到下一帧中的不同位置。因此，通常为每个块定义运动矢量以指示水平和垂直维度中的移动量。用$$mv(x,y)$$来表示运动矢量，其中$$x,y$$均为整数。However, motion vectors from a subsampled residual frame can be combined with those from the original resolution of the residual frame such that the subsampled motion vectors are expressed as fractions. Figure 2-23 illustrates this concept, where the final motion vector is 12.5 pixels away horizontally in the current frame from the original location (0, 0) in the reference frame; using a half-pixel (or half-pel) precision of motion vectors.（没看懂，先放在这里吧，后续再补充。之后的内容也需要补充，在此就不再贴了）



